<div>
  <h1>Redux with vanilla typescript, store=</h1>
  <pre data-myreduxstate>....</pre>
</div>
<script>
  import type { AnyObj, ApiResponse, Question } from "../store/types";
  import { createStore, applyMiddleware, Dispatch } from "redux";
  import thunk, { ThunkAction } from "redux-thunk";

  import { QUESTIONS_ENDPOINT } from "../settings/settings";

  import {
    getAllCategoriesFromSS,
    getAllQuestionsFromSS,
    getCurrentLearningCategoryFromLS,
    getNextQuestionUrlsFromSS,
    getObjFromLS,
    setArrayToSessionStorage,
    setObjToLS,
    setStringToLS,
  } from "../utils/utils";

  const CURRENT_LEARNING_CATEGORY_STORAGE_KEY =
    "CURRENT_LEARNING_CATEGORY_STORAGE_KEY";
  const ALL_QUESTIONS_STORAGE_KEY = "ALL_QUESTIONS_STORAGE_KEY";
  const ALL_CATEGORIES_STORAGE_KEY = "ALL_CATEGORIES_STORAGE_KEY";
  const NEXT_QUESTION_URLS_STORAGE_KEY = "NEXT_QUESTION_URLS_STORAGE_KEY";
  const USER_ANSWERS_STORAGE_KEY = "USER_ANSWERS_STORAGE_KEY";

  // Define your state type

  export interface RootState {
    userAnswers: AnyObj;
    currentLearningCategory: string;
    allQuestions: Question[];
    allCategories: string[];
    nextQuestionUrls: string[];
    correctAnswersCount: number;
    wrongAnswersCount: number;
  }

  // Define your reducer
  const initialState: RootState = {
    userAnswers: getObjFromLS(USER_ANSWERS_STORAGE_KEY),
    currentLearningCategory: getCurrentLearningCategoryFromLS(),
    allQuestions: getAllQuestionsFromSS(),
    allCategories: getAllCategoriesFromSS(),
    nextQuestionUrls: getNextQuestionUrlsFromSS(),
    correctAnswersCount: 0,
    wrongAnswersCount: 0,
  };

  interface FetchStore {
    type: "FETCH_STORE";
    payload: {
      allQuestions: Question[];
      allCategories: string[];
      nextQuestionUrls: string[];
    };
  }

  interface PopElementFromNextQuestionUrls {
    type: "POP_ELEMENT_FROM_NEXT_QUESTION_URLS";
  }

  interface SetCurrentLearningCategory {
    type: "SET_CURRENT_LEARNING_CATEGORY";
    payload: string;
  }

  interface AddUserAnswer {
    type: "ADD_USER_ANSWER";
    payload: AnyObj;
  }

  type AllActions =
    | FetchStore
    | PopElementFromNextQuestionUrls
    | SetCurrentLearningCategory
    | AddUserAnswer;

  const rootReducer = (state: RootState = initialState, action: AllActions) => {
    switch (action.type) {
      case "FETCH_STORE": {
        const allQuestions = action.payload.allQuestions;
        const allCategories = action.payload.allCategories;
        const nextQuestionUrls = action.payload.nextQuestionUrls;

        setArrayToSessionStorage(ALL_QUESTIONS_STORAGE_KEY, allQuestions);
        setArrayToSessionStorage(ALL_CATEGORIES_STORAGE_KEY, allCategories);
        setArrayToSessionStorage(
          NEXT_QUESTION_URLS_STORAGE_KEY,
          nextQuestionUrls
        );

        return {
          ...state,
          allQuestions,
          allCategories,
          nextQuestionUrls,
        };
      }

      case "POP_ELEMENT_FROM_NEXT_QUESTION_URLS": {
        const nextQuestionUrls = state.nextQuestionUrls.slice(0, -1);

        setArrayToSessionStorage(
          NEXT_QUESTION_URLS_STORAGE_KEY,
          nextQuestionUrls
        );

        return { ...state, nextQuestionUrls };
      }

      case "SET_CURRENT_LEARNING_CATEGORY": {
        const currentLearningCategory = action.payload;

        setStringToLS(
          CURRENT_LEARNING_CATEGORY_STORAGE_KEY,
          currentLearningCategory
        );

        return { ...state, currentLearningCategory };
      }

      case "ADD_USER_ANSWER": {
        const userAnswers = { ...state.userAnswers, ...action.payload };
        setObjToLS(USER_ANSWERS_STORAGE_KEY, userAnswers);

        const correctAnswersCount = Object.values(userAnswers).filter(
          (answer) =>
            answer.clickedAnswer &&
            answer.clickedAnswer === answer.correctAnswer
        ).length;

        const wrongAnswersCount = Object.values(userAnswers).filter(
          (answer) =>
            answer.clickedAnswer &&
            answer.clickedAnswer !== answer.correctAnswer
        ).length;

        return {
          ...state,
          userAnswers,
          correctAnswersCount,
          wrongAnswersCount,
        };
      }

      default:
        return state;
    }
  };

  // Create your store with Thunk middleware
  const store = createStore(rootReducer, applyMiddleware(thunk));

  // Define your Thunk action
  export const fetchStore = (): ThunkAction<
    void,
    RootState,
    unknown,
    AllActions
  > => {
    return async (
      dispatch: Dispatch<AllActions>,
      getState: () => RootState
    ) => {
      const stateSnapshot = getState();
      if (
        stateSnapshot.allCategories.length > 0 &&
        stateSnapshot.allQuestions.length > 0
      ) {
        // means that store is allready fetched from session storage
        return;
      }

      const apiResponse: Promise<ApiResponse> = fetch(QUESTIONS_ENDPOINT).then(
        (response) => response.json() as Promise<ApiResponse>
      );

      const {
        allCategories,
        allQuestions,
        questionsPerCategoryCountObj,
        firstQuestionUrlsObj,
      } = await apiResponse;

      const allQuestionsShuffled = allQuestions; // .sort(() => 0.5 - Math.random());

      // NEXT QUESTION URLS
      const nextQuestionUrls: string[] = allQuestionsShuffled
        .filter((q) => {
          // filter out questions like allready seen, etc...

          return true;
        })
        .slice(0, 10)
        .map((question, index) => {
          // createQuestionUrl(question, stateSnapshot.currentLearningCategory)

          return " to bedzie url" + index;
        });

      setTimeout(() => {
        dispatch({
          type: "FETCH_STORE",
          payload: {
            allQuestions: allQuestionsShuffled,
            allCategories,
            nextQuestionUrls,
          },
        });
      }, 2222);
    };
  };

  const unsubscribe = store.subscribe(update);

  update(); // call it if no action is dispatched after subscribe !!!

  // store.dispatch({
  //   type: "POP_ELEMENT_FROM_NEXT_QUESTION_URLS",
  // });

  // store.dispatch({
  //   type: "SET_CURRENT_LEARNING_CATEGORY",
  //   payload: "b",
  // });

  store.dispatch(fetchStore());

  // Example event listener for a button that dispatches the Thunk action
  const button = document.getElementById("add-question-button");
  button?.addEventListener("click", () => {
    //  ....
  });

  // ANSWER BUTTONS
  const answerButtons = document.querySelectorAll("[data-answer]");
  answerButtons.forEach((answerButton) => {
    answerButton.addEventListener("click", () => {
      const clickedAnswer = answerButton.getAttribute("data-answer");
      const questionId = answerButton.getAttribute("data-question-id");
      const correctAnswer = answerButton.getAttribute("data-correct-answer");

      if (!questionId) return;

      store.dispatch({
        type: "ADD_USER_ANSWER",
        payload: { [questionId]: { questionId, clickedAnswer, correctAnswer } },
      });
    });
  });

  // this function is called on every store change
  function update() {
    const storeSnapshot = store.getState();

    const preElements = document.querySelectorAll("[data-myreduxstate]");

    preElements.forEach((preElement) => {
      preElement.innerHTML = JSON.stringify(store.getState(), null, 2);
    });

    document
      .querySelectorAll('[data-selector="correct-answers-count"]')
      .forEach((el) => {
        el.innerHTML = storeSnapshot.correctAnswersCount.toString();
      });

    document
      .querySelectorAll('[data-selector="wrong-answers-count"]')
      .forEach((el) => {
        el.innerHTML = storeSnapshot.wrongAnswersCount.toString();
      });
  }
</script>
