---
---

<!-- <div>
  <h1>Redux with vanilla typescript</h1>
  <button id="add-question-button">add-question-button</button>

  <p>store:</p>
  <pre data-myreduxstate>....</pre>
</div> -->
<script>
  import { createStore, applyMiddleware, Dispatch } from "redux";
  import thunk, { ThunkAction } from "redux-thunk";

  import type { DataReceivedFromEndpoint, Question } from "../store/types";
  import {
    createQuestionUrl,
    getArrayFromSessionStorage,
    getStringFromLocalStorage,
    setArrayToSessionStorage,
  } from "../utils/utils";

  const FETCH_STORE_ACTION = "FETCH_STORE_ACTION";
  const ACTION_SET_CURRENT_LEARNING_CATEGORY =
    "ACTION_SET_CURRENT_LEARNING_CATEGORY";
  const FETCH_ALL_QUESTIONS = "FETCH_ALL_QUESTIONS";
  const FETCH_ALL_CATEGORIES = "FETCH_ALL_CATEGORIES";
  const ACTION_RAND_NEXT_QUESTION_URLS = "ACTION_RAND_NEXT_QUESTION_URLS";
  const POP_ELEMENT_FROM_NEXT_QUESTION_URLS =
    "POP_ELEMENT_FROM_NEXT_QUESTION_URLS";

  const CURRENT_LEARNING_CATEGORY_STORAGE_KEY =
    "CURRENT_LEARNING_CATEGORY_STORAGE_KEY";
  const ALL_QUESTIONS_STORAGE_KEY = "ALL_QUESTIONS_STORAGE_KEY";
  const ALL_CATEGORIES_STORAGE_KEY = "ALL_CATEGORIES_STORAGE_KEY";
  const NEXT_QUESTION_URLS_STORAGE_KEY = "NEXT_QUESTION_URLS_STORAGE_KEY";

  // Define your state type
  export interface RootState {
    currentLearningCategory: string;
    allQuestions: Question[];
    allCategories: string[];
    nextQuestionUrls: string[];
  }

  // Define your reducer
  const initialState: RootState = {
    currentLearningCategory: getStringFromLocalStorage(
      CURRENT_LEARNING_CATEGORY_STORAGE_KEY,
      "b"
    ),
    allQuestions: getArrayFromSessionStorage(
      ALL_QUESTIONS_STORAGE_KEY
    ) as Question[],
    allCategories: getArrayFromSessionStorage(
      ALL_CATEGORIES_STORAGE_KEY
    ) as string[],
    nextQuestionUrls: getArrayFromSessionStorage(
      NEXT_QUESTION_URLS_STORAGE_KEY
    ) as string[],
  };

  // Define your action types
  interface FetchAllQuestionsAction {
    type: typeof FETCH_ALL_QUESTIONS;
    payload: Question[];
  }

  interface FetchAllCategoriesAction {
    type: typeof FETCH_ALL_CATEGORIES;
    payload: string[];
  }

  interface ActionRandNextQuestionUrls {
    type: typeof ACTION_RAND_NEXT_QUESTION_URLS;
    payload: string[];
  }

  interface FetchStoreAction {
    type: typeof FETCH_STORE_ACTION;
    payload: {
      allQuestions: Question[];
      allCategories: string[];
      nextQuestionUrls: string[];
    };
  }

  interface PopElementFromNextQuestionUrls {
    type: typeof POP_ELEMENT_FROM_NEXT_QUESTION_URLS;
  }

  type AllActions =
    | FetchStoreAction
    | FetchAllQuestionsAction
    | FetchAllCategoriesAction
    | ActionRandNextQuestionUrls
    | PopElementFromNextQuestionUrls;

  const rootReducer = (state: RootState = initialState, action: AllActions) => {
    switch (action.type) {
      case FETCH_STORE_ACTION: {
        const allQuestions = action.payload.allQuestions;
        const allCategories = action.payload.allCategories;
        const nextQuestionUrls = action.payload.nextQuestionUrls;

        setArrayToSessionStorage(ALL_QUESTIONS_STORAGE_KEY, allQuestions);
        setArrayToSessionStorage(ALL_CATEGORIES_STORAGE_KEY, allCategories);
        setArrayToSessionStorage(
          NEXT_QUESTION_URLS_STORAGE_KEY,
          nextQuestionUrls
        );

        return {
          ...state,
          allQuestions,
          allCategories,
          nextQuestionUrls,
        };
      }

      case FETCH_ALL_QUESTIONS:
        const allQuestions = action.payload.slice(0, 1);
        setArrayToSessionStorage(ALL_QUESTIONS_STORAGE_KEY, allQuestions);

        return { ...state, allQuestions };
      case FETCH_ALL_CATEGORIES:
        const allCategories = action.payload;
        setArrayToSessionStorage(ALL_CATEGORIES_STORAGE_KEY, allCategories);

        return { ...state, allCategories };
      case ACTION_RAND_NEXT_QUESTION_URLS:
        return { ...state, nextQuestionUrls: action.payload };

      case POP_ELEMENT_FROM_NEXT_QUESTION_URLS:
        const nextQuestionUrls = state.nextQuestionUrls.slice(0, -1);

        setArrayToSessionStorage(
          NEXT_QUESTION_URLS_STORAGE_KEY,
          nextQuestionUrls
        );

        return { ...state, nextQuestionUrls };
      default:
        return state;
    }
  };

  // Create your store with Thunk middleware
  const store = createStore(rootReducer, applyMiddleware(thunk));
  // export default store;
  console.log("store is ready: ", store.getState());

  // Define your Thunk action
  export const fetchAllQuestions = (): ThunkAction<
    void,
    RootState,
    unknown,
    AllActions
  > => {
    return async (
      dispatch: Dispatch<AllActions>,
      getState: () => RootState
    ) => {
      const stateSnapshot = getState();
      if (
        stateSnapshot.allCategories.length > 0 &&
        stateSnapshot.allQuestions.length > 0
      ) {
        return;
      }

      const fetchResponse = await fetch("../data.json");
      const dataReceivedFromEndpoint: DataReceivedFromEndpoint =
        await fetchResponse.json();

      // ALL QUESTIONS
      const allQuestions: Question[] =
        dataReceivedFromEndpoint.allQuestions.map(
          (questionReceivedFromEndpoint, index) => {
            const q = questionReceivedFromEndpoint;

            const question: Question = {
              id: q.id,
              text: q.t,
              media: q.m || "placeholder.png",
              a: q.a || "",
              b: q.b || "",
              c: q.c || "",
              correctAnswer: q.r,
              categories: q.cats,
              score: q.s,
            };

            return question;
          }
        );

      const allQuestionsShuffled = allQuestions.sort(() => 0.5 - Math.random());

      // ALL CATEGORIES
      const allCategories: string[] = dataReceivedFromEndpoint.allCategories;

      // NEXT QUESTION URLS
      const nextQuestionUrls: string[] = allQuestionsShuffled
        .filter((q) => {
          // filter out questions like allready seen, etc...

          return true;
        })
        .slice(0, 500)
        .map((question) =>
          createQuestionUrl(question, stateSnapshot.currentLearningCategory)
        );

      dispatch({
        type: FETCH_STORE_ACTION,
        payload: {
          allQuestions: allQuestionsShuffled,
          allCategories,
          nextQuestionUrls,
        },
      });
    };
  };

  // Subscribe to changes in the store
  const update = () => {
    const preElements = document.querySelectorAll("[data-myreduxstate]");

    preElements.forEach((preElement) => {
      preElement.innerHTML = JSON.stringify(
        store.getState().nextQuestionUrls,
        null,
        2
      );
    });
  };

  const unsubscribe = store.subscribe(update);

  // update(); // call it if no action is dispatched after subscribe !!!

  store.dispatch({
    type: POP_ELEMENT_FROM_NEXT_QUESTION_URLS,
  });

  // To stop listening for changes:
  // unsubscribe();

  // Dispatch your Thunk action
  // store.dispatch(addQuestion(6)); // Note: You should use store.dispatch to dispatch Thunk actions

  store.dispatch(fetchAllQuestions());

  // Example event listener for a button that dispatches the Thunk action
  const button = document.getElementById("add-question-button");
  button?.addEventListener("click", () => {
    //  ....
  });
</script>
