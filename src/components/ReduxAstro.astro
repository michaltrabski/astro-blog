---
---

<!-- <div>
  <h1>Redux with vanilla typescript</h1>
  <button id="add-question-button">add-question-button</button>

  <p>store:</p>
  <pre data-myreduxstate>....</pre>
</div> -->
<script>
  import { createStore, applyMiddleware, Dispatch } from "redux";
  import thunk, { ThunkAction } from "redux-thunk";

  import type { DataReceivedFromEndpoint, Question } from "../store/types";
  import {
    createQuestionUrl,
    getAllCategoriesFromSS,
    getAllQuestionsFromSS,
    getArrayFromSessionStorage,
    getCurrentLearningCategoryFromLS,
    getNextQuestionUrlsFromSS,
    getStringFromLocalStorage,
    setArrayToSessionStorage,
    setStringToLS,
  } from "../utils/utils";

  const FETCH_STORE = "FETCH_STORE";
  const SET_CURRENT_LEARNING_CATEGORY = "SET_CURRENT_LEARNING_CATEGORY";
  // const FETCH_ALL_QUESTIONS = "FETCH_ALL_QUESTIONS";
  // const FETCH_ALL_CATEGORIES = "FETCH_ALL_CATEGORIES";
  // const ACTION_RAND_NEXT_QUESTION_URLS = "ACTION_RAND_NEXT_QUESTION_URLS";
  const POP_ELEMENT_FROM_NEXT_QUESTION_URLS =
    "POP_ELEMENT_FROM_NEXT_QUESTION_URLS";

  const CURRENT_LEARNING_CATEGORY_STORAGE_KEY =
    "CURRENT_LEARNING_CATEGORY_STORAGE_KEY";
  const ALL_QUESTIONS_STORAGE_KEY = "ALL_QUESTIONS_STORAGE_KEY";
  const ALL_CATEGORIES_STORAGE_KEY = "ALL_CATEGORIES_STORAGE_KEY";
  const NEXT_QUESTION_URLS_STORAGE_KEY = "NEXT_QUESTION_URLS_STORAGE_KEY";

  // Define your state type
  export interface RootState {
    currentLearningCategory: string;
    allQuestions: Question[];
    allCategories: string[];
    nextQuestionUrls: string[];
  }

  // Define your reducer
  const initialState: RootState = {
    currentLearningCategory: getCurrentLearningCategoryFromLS(),
    allQuestions: getAllQuestionsFromSS(),
    allCategories: getAllCategoriesFromSS(),
    nextQuestionUrls: getNextQuestionUrlsFromSS(),
  };

  // Define your action types
  // interface fetchStoreAction {
  //   type: typeof FETCH_ALL_QUESTIONS;
  //   payload: Question[];
  // }

  // interface FetchAllCategoriesAction {
  //   type: typeof FETCH_ALL_CATEGORIES;
  //   payload: string[];
  // }

  // interface ActionRandNextQuestionUrls {
  //   type: typeof ACTION_RAND_NEXT_QUESTION_URLS;
  //   payload: string[];
  // }

  interface FetchStore {
    type: typeof FETCH_STORE;
    payload: {
      allQuestions: Question[];
      allCategories: string[];
      nextQuestionUrls: string[];
    };
  }

  interface PopElementFromNextQuestionUrls {
    type: typeof POP_ELEMENT_FROM_NEXT_QUESTION_URLS;
  }

  interface SetCurrentLearningCategory {
    type: typeof SET_CURRENT_LEARNING_CATEGORY;
    payload: string;
  }

  type AllActions =
    | FetchStore
    // | fetchStoreAction
    // | FetchAllCategoriesAction
    // | ActionRandNextQuestionUrls
    | PopElementFromNextQuestionUrls
    | SetCurrentLearningCategory;

  const rootReducer = (state: RootState = initialState, action: AllActions) => {
    switch (action.type) {
      case FETCH_STORE: {
        const allQuestions = action.payload.allQuestions;
        const allCategories = action.payload.allCategories;
        const nextQuestionUrls = action.payload.nextQuestionUrls;

        setArrayToSessionStorage(ALL_QUESTIONS_STORAGE_KEY, allQuestions);
        setArrayToSessionStorage(ALL_CATEGORIES_STORAGE_KEY, allCategories);
        setArrayToSessionStorage(
          NEXT_QUESTION_URLS_STORAGE_KEY,
          nextQuestionUrls
        );

        return {
          ...state,
          allQuestions,
          allCategories,
          nextQuestionUrls,
        };
      }

      // case FETCH_ALL_QUESTIONS:
      //   const allQuestions = action.payload;
      //   setArrayToSessionStorage(ALL_QUESTIONS_STORAGE_KEY, allQuestions);

      //   return { ...state, allQuestions };
      // case FETCH_ALL_CATEGORIES:
      //   const allCategories = action.payload;
      //   setArrayToSessionStorage(ALL_CATEGORIES_STORAGE_KEY, allCategories);

      //   return { ...state, allCategories };
      // case ACTION_RAND_NEXT_QUESTION_URLS:
      //   return { ...state, nextQuestionUrls: action.payload };

      case POP_ELEMENT_FROM_NEXT_QUESTION_URLS: {
        const nextQuestionUrls = state.nextQuestionUrls.slice(0, -1);

        setArrayToSessionStorage(
          NEXT_QUESTION_URLS_STORAGE_KEY,
          nextQuestionUrls
        );

        return { ...state, nextQuestionUrls };
      }
      case SET_CURRENT_LEARNING_CATEGORY: {
        const currentLearningCategory = action.payload;

        setStringToLS(
          CURRENT_LEARNING_CATEGORY_STORAGE_KEY,
          currentLearningCategory
        );

        return { ...state, currentLearningCategory };
      }
      default:
        return state;
    }
  };

  // Create your store with Thunk middleware
  const store = createStore(rootReducer, applyMiddleware(thunk));
  // export default store;

  // Define your Thunk action
  export const fetchStore = (): ThunkAction<
    void,
    RootState,
    unknown,
    AllActions
  > => {
    return async (
      dispatch: Dispatch<AllActions>,
      getState: () => RootState
    ) => {
      const stateSnapshot = getState();
      if (
        stateSnapshot.allCategories.length > 0 &&
        stateSnapshot.allQuestions.length > 0
      ) {
        return;
      }

      const fetchResponse = await fetch("../data.json");
      const dataReceivedFromEndpoint: DataReceivedFromEndpoint =
        await fetchResponse.json();

      // ALL QUESTIONS
      const allQuestions: Question[] =
        dataReceivedFromEndpoint.allQuestionsFromEndpoint.map(
          (questionReceivedFromEndpoint, index) => {
            const q = questionReceivedFromEndpoint;

            const question: Question = {
              id: q.id,
              text: q.t,
              media: q.m || "placeholder.png",
              a: q.a || "",
              b: q.b || "",
              c: q.c || "",
              correctAnswer: q.r,
              categories: q.cats,
              score: q.s,
            };

            return question;
          }
        );

      const allQuestionsShuffled = allQuestions.sort(() => 0.5 - Math.random());

      // ALL CATEGORIES
      const allCategories: string[] = dataReceivedFromEndpoint.allCategories;

      // NEXT QUESTION URLS
      const nextQuestionUrls: string[] = allQuestionsShuffled
        .filter((q) => {
          // filter out questions like allready seen, etc...

          return true;
        })
        .slice(0, 500)
        .map((question) =>
          createQuestionUrl(question, stateSnapshot.currentLearningCategory)
        );

      dispatch({
        type: FETCH_STORE,
        payload: {
          allQuestions: allQuestionsShuffled,
          allCategories,
          nextQuestionUrls,
        },
      });
    };
  };

  // Subscribe to changes in the store
  const update = () => {
    // console.log("store is ready: ", store.getState());

    const preElements = document.querySelectorAll("[data-myreduxstate]");

    preElements.forEach((preElement) => {
      preElement.innerHTML = JSON.stringify(store.getState(), null, 2);
    });
  };

  const unsubscribe = store.subscribe(update);

  // update(); // call it if no action is dispatched after subscribe !!!

  store.dispatch({
    type: POP_ELEMENT_FROM_NEXT_QUESTION_URLS,
  });

  store.dispatch({
    type: SET_CURRENT_LEARNING_CATEGORY,
    payload: "b",
  });

  // To stop listening for changes:
  // unsubscribe();

  // Dispatch your Thunk action
  // store.dispatch(addQuestion(6)); // Note: You should use store.dispatch to dispatch Thunk actions

  store.dispatch(fetchStore());

  // Example event listener for a button that dispatches the Thunk action
  const button = document.getElementById("add-question-button");
  button?.addEventListener("click", () => {
    //  ....
  });
</script>
